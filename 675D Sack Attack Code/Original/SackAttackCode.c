#pragma config(UART_Usage, UART1, VEX_2x16_LCD, baudRate19200, IOPins, None, None)
#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    gyro,           sensorGyro)
#pragma config(Sensor, in2,    pot,            sensorPotentiometer)
#pragma config(Sensor, in3,    intakePot,      sensorPotentiometer)
#pragma config(Sensor, I2C_1,  leftDrive,      sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_2,  rightDrive,     sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Motor,  port1,           LBDrive,       tmotorVex393, openLoop, encoder, encoderPort, I2C_1, 1000)
#pragma config(Motor,  port2,           LFDrive,       tmotorVex393, openLoop)
#pragma config(Motor,  port3,           LTLift,        tmotorVex269, openLoop)
#pragma config(Motor,  port4,           LBLift,        tmotorVex269, openLoop)
#pragma config(Motor,  port5,           ScoopLeft,     tmotorVex269, openLoop)
#pragma config(Motor,  port6,           ScoopRight,    tmotorVex269, openLoop)
#pragma config(Motor,  port7,           RTLift,        tmotorVex269, openLoop)
#pragma config(Motor,  port8,           RBLift,        tmotorVex393, openLoop)
#pragma config(Motor,  port9,           RFDrive,       tmotorVex393, openLoop)
#pragma config(Motor,  port10,          RBDrive,       tmotorVex393, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)
#pragma competitionControl(Competition)
#pragma autonomousDuration(15)
#pragma userControlDuration(120)

#include "Vex_Competition_Includes.c"

#ifndef Recorder
#include "JakesWorkingAutonRecorder.c"
#endif

#ifndef DEFINEFILE
#include "SackAttackCodeDefines.c"
#endif

bool arcadeControl;
bool halfPower;
bool secondJoystickDriving;
bool testingAutonomousMode;
bool RightTurn;
bool gripperState; //True if intaking and False if outtaking
bool secondJoystickIntaking;
bool motorsDisabled;
bool isTurnTaskRunning;
int count, motorCount, intakeAngle, choice, armChoice, armGoal;
/***************FUNCTION PROTOTYPES*************************/
int motorPowerLeft(bool arcade, bool joy2, bool halfPower);
int motorPowerRight(bool arcade, bool joy2, bool halfPower);
int armPower(int armGoal, bool gripper);
void checkHalfPower();
void checkGripperState();
void setIntakeAngle();
void checkMotorsDisabled();
void setRightTurn();
void setTurns();
void checkTurnTaskRunning();
void printToDebugStream();
task autonomousDrive();
task ninetyTurn();
task autonomousTestingTask();
task flipTurn();
task twoSeventyTurn();
task setMotors();
task displayBatteryLevel();
task autonomousHelper();
/***************END OF PROTOTYPES**************************/
typedef struct
{
  int LeftDriveMotors;
  int RightDriveMotors;
  int ArmMotors;
  int intakes;
}MotorPowers;
MotorPowers p;

typedef struct
{
  int intakeGround;
  int intakeLift;
  int intakeDump;
  int intakeDescore;
} intakeValues;
intakeValues v;

void pre_auton()
{
  halfPower = false;
  arcadeControl = true;
  secondJoystickDriving = true;
  secondJoystickIntaking = false;
  testingAutonomousMode = false;
  gripperState = false;
  motorsDisabled = false;
  p.LeftDriveMotors = 0;
  p.RightDriveMotors = 0;
  p.ArmMotors = 0;
  v.intakeGround = 1000;
  v.intakeLift = 2000;
  v.intakeDump = 3000;
  v.intakeDescore = 4000;
  count = 0;
  motorCount = 0;
  choice = 1;
}

task autonomous()
{
}

task usercontrol()
{
  while (true)
  {
    if(testingAutonomousMode)
    {
      if(getTaskState(autonomousTestingTask) == taskStateStopped)
        StartTask(autonomousTestingTask);
      if(getTaskState(autonomousDrive) == taskStateStopped)
        StartTask(autonomousDrive);
    }
    else if(!testingAutonomousMode)
    {
      StopTask(autonomousDrive);
      checkHalfPower();
      setRightTurn();
      checkMotorsDisabled();
      checkTurnTaskRunning();
      checkGripperState();
      setTurns();
      if(getTaskState(setMotors) == taskStateStopped)
        StartTask(setMotors);
    }
  }
}



task autonomousTestingTask()
{
  while(vexRT[Btn5U] != 1)
  {
    motor[LBDrive] = MJCh2;
    motor[LFDrive] = MJCh2;
    motor[RBDrive] = MJCh3;
    motor[RFDrive] = MJCh3;
  }
  StartTask(autonomousHelper);
}









task autonomousDrive()
{
  p.LeftDriveMotors = motorPowerLeft(arcadeControl, secondJoystickDriving, halfPower);
  p.RightDriveMotors = motorPowerRight(arcadeControl, secondJoystickDriving, halfPower);
  motor[LBDrive]  = p.LeftDriveMotors;
  motor[LFDrive]  = p.LeftDriveMotors;
  motor[RFDrive]  = p.RightDriveMotors;
  motor[RBDrive]  = p.RightDriveMotors;

}


task setMotors()
{
  if(getTaskState(displayBatteryLevel) == taskStateStopped)
    StartTask(displayBatteryLevel);
  if(!motorsDisabled)
  {
    if(getTaskState(ninetyTurn) == taskStateRunning && (abs(vexRT[Ch2]) > 30 || abs(vexRT[Ch3]) > 30))
      StopTask(ninetyTurn);
    else if(getTaskState(flipTurn) == taskStateRunning && (abs(vexRT[Ch2]) > 30 || abs(vexRT[Ch3]) > 30))
      StopTask(flipTurn);
    else if(getTaskState(twoSeventyTurn) == taskStateRunning && (abs(vexRT[Ch2]) > 30 || abs(vexRT[Ch3]) > 30))
      StopTask(twoSeventyTurn);
    else
    {
      p.LeftDriveMotors = motorPowerLeft(arcadeControl, secondJoystickDriving, halfPower);
      p.RightDriveMotors = motorPowerRight(arcadeControl, secondJoystickDriving, halfPower);
    }
    p.intakes = 0;
    p.ArmMotors = armPower(127, gripperState);
    motor[LBDrive]  = p.LeftDriveMotors;
  motor[LFDrive]  = p.LeftDriveMotors;
  motor[RFDrive]  = p.RightDriveMotors;
  motor[RBDrive]  = p.RightDriveMotors;
  motor[LBLift] = p.ArmMotors;
  motor[LTLift] = p.ArmMotors;
  motor[RTLift] = p.ArmMotors;
  motor[RBLift] = p.ArmMotors;
  }

  else if(motorsDisabled)
  {
    motor[port1] = 0;
    motor[port2] = 0;
    motor[port3] = 0;
    motor[port4] = 0;
    motor[port5] = 0;
    motor[port6] = 0;
    motor[port7] = 0;
    motor[port8] = 0;
    motor[port9] = 0;
    motor[port10] = 0;
  }
}

int motorPowerLeft(bool arcade, bool joy2, bool halfPower)
{
  int v = 0;
  if(!joy2)
  {
    if(arcade)
    {
      if(halfPower)
        v = (MJCh3 + MJCh4) / 4;
      else
        v = (MJCh3 + MJCh4) / 2;
    }
    else if(!arcade)
    {
      if(halfPower)
      {
        v = MJCh3 / 2;
      }
      else
        v = MJCh3;
    }
  }

  else
  {
    if(arcade)
    {
      if(halfPower)
        v = (PJCh3 + PJCh4) / 4;
      else
        v = (PJCh3 + PJCh4) / 2;
    }
    else if(!arcade)
    {
      if(halfPower)
      {
        v = PJCh3 / 2;
      }
      else
        v = PJCh3;
    }
  }
  return v;
}

int motorPowerRight(bool arcade, bool joy2, bool halfPower)
{
  int v = 0;
  if(!joy2)
  {
    if(arcade)
    {
      if(halfPower)
        v = (MJCh1 + MJCh2) / 4;
      else
        v = (MJCh1 + MJCh2) / 2;
    }
    else if(!arcade)
    {
      if(halfPower)
      {
        v = MJCh2 / 2;
      }
      else
        v = MJCh2;
    }
  }

  else
  {
    if(arcade)
    {
      if(halfPower)
        v = (PJCh2 + PJCh1) / 4;
      else
        v = (PJCh2 + PJCh1) / 2;
    }
    else if(!arcade)
    {
      if(halfPower)
      {
        v = PJCh2 / 2;
      }
      else
        v = PJCh2;
    }
  }
  return v;
}

int armPower(int armGoal, bool gripper)
{
  if(!gripper)
    gripper = true;
int a = ((SensorValue(pot) - armGoal) / 3 > 127) ? 127 : ((SensorValue(pot) - armGoal) / 3);
  return a;
}

void setIntakeAngle()
{
  // choice = 1 ground 2 lift 3 dump 4 descore
  if(MJ7D == 1)
    choice = 1;
  else if(MJ7L == 1)
    choice = 2;
  else if(MJ7U == 1)
    choice = 3;
  else if(MJ7R == 1)
    choice = 4;

  switch(choice)
  {
  case 1:
    intakeAngle = v.intakeGround;
    break;
  case 2:
    intakeAngle = v.intakeLift;
    break;
  case 3:
    intakeAngle = v.intakeDump;
    break;
  case 4:
    intakeAngle = v.intakeDescore;
    break;
  }
}

void setArmLift()
{
  // 1 ground //2 trough // 3 high
  if(MJ8L == 1)
  {
    armChoice = 1;
  }
  else if(MJ8U == 1)
  {
    armChoice = 2;
  }
  else if(MJ8R == 1)
  {
    armChoice = 3;
  }
  switch(armChoice)
  {
  case 1:
    armGoal = 1000;
    break;
  case 2:
    armGoal = 2000;
    break;
  case 3:
    armGoal = 3000;
    break;
  }
}

void checkHalfPower()
{
  if(MJ8D == 1 && !halfPower)
    halfPower = true;
  else if(MJ8D == 1 && halfPower)
    halfPower = false;
}

void setRightTurn()
{
  if(count % 2 == 1)
    RightTurn = true;
  else
    RightTurn = false;
}

void checkGripperState()
{
  if(!secondJoystickIntaking)
  {
    if(MJ6U == 1)
      gripperState = true;
    else if(MJ6D == 1)
      gripperState = false;
  }
  else if(secondJoystickIntaking)
  {
    if(PJ6U == 1)
      gripperState = true;
    else if(PJ6D == 1)
      gripperState = false;
  }
}

void checkMotorsDisabled()
{
  if(MJ7D == 1)
    motorCount++;
  if(motorCount % 2 == 0)
    motorsDisabled = false;
  else if(motorCount % 2 == 1)
    motorsDisabled = true;
}

void checkTurnTaskRunning()
{
  if(getTaskState(ninetyTurn) == taskStateRunning || getTaskState(flipTurn) == taskStateRunning || getTaskState(twoSeventyTurn) == taskStateRunning)
    isTurnTaskRunning = true;
  else
    isTurnTaskRunning = false;
}

void setTurns()
{
  if(MJ6D == 1 && !isTurnTaskRunning)
    changeCount(&count);
  if(MJ6D == 1 && isTurnTaskRunning)
  {StopTask(ninetyTurn); StopTask(flipTurn); StopTask(twoSeventyTurn);}
  if(MJ6U == 1)
    StartTask(ninetyTurn);
  else if(MJ5U == 1)
    StartTask(flipTurn);
  else if(MJ5D == 1)
    StartTask(twoSeventyTurn);
}

void printToDebugStream()
{}
//********************TURN TASKS****************************//////
task centerIntake()
{
p.intakes = (SensorValue(intakePot) / 3 > 127) ? 127 : SensorValue(intakePot) / 3;
}


task ninetyTurn()
{
  if(RightTurn)
  {
    if(halfPower)
    {
      while(SensorValue(gyro) < 900)
      {
        motor[LBDrive] = halfPow;
        motor[LFDrive] = halfPow;
        motor[RBDrive] = negHalfPow;
        motor[RFDrive] = negHalfPow;
      }
    }
    else
    {
      while(SensorValue(gyro) < 900)
      {
        motor[LBDrive] = fullPower;
        motor[LFDrive] = fullPower;
        motor[RBDrive] = fullNegPower;
        motor[RFDrive] = fullNegPower;
      }
    }
  }
  else
  {
    if(halfPower)
    {
      while(SensorValue(gyro) < 900)
      {
        motor[RBDrive] = halfPow;
        motor[RFDrive] = halfPow;
        motor[LBDrive] = negHalfPow;
        motor[LFDrive] = negHalfPow;
      }
    }
    else if(!halfPower)
    {
      while(SensorValue(gyro) < 900)
      {
        motor[RBDrive] = fullPower;
        motor[RFDrive] = fullPower;
        motor[LBDrive] = fullNegPower;
        motor[LFDrive] = fullNegPower;
      }
    }
  }
}

task flipTurn()
{
  if(RightTurn)
  {
    if(halfPower)
    {
      while(SensorValue(gyro) < 1800)
      {
        motor[LBDrive] = halfPow;
        motor[LFDrive] = halfPow;
        motor[RBDrive] = negHalfPow;
        motor[RFDrive] = negHalfPow;
      }
    }
    else
    {
      while(SensorValue(gyro) < 1800)
      {
        motor[LBDrive] = fullPower;
        motor[LFDrive] = fullPower;
        motor[RBDrive] = fullNegPower;
        motor[RFDrive] = fullNegPower;

      }
    }
  }
  else
  {
    if(halfPower)
    {
      while(SensorValue(gyro) < 1800)
      {
        motor[RBDrive] = halfPow;
        motor[RFDrive] = halfPow;
        motor[LBDrive] = negHalfPow;
        motor[LFDrive] = negHalfPow;
      }
    }
    else if(!halfPower)
    {
      while(SensorValue(gyro) < 1800)
      {
        motor[RBDrive] = fullPower;
        motor[RFDrive] = fullPower;
        motor[LBDrive] = fullNegPower;
        motor[LFDrive] = fullNegPower;
      }
    }
  }
}
task twoSeventyTurn()
{
  if(RightTurn)
  {
    if(halfPower)
    {
      while(SensorValue(gyro) < 2700)
      {
        motor[LBDrive] = halfPow;
        motor[LFDrive] = halfPow;
        motor[RBDrive] = negHalfPow;
        motor[RFDrive] = negHalfPow;
      }
    }
    else
    {
      while(SensorValue(gyro) < 2700)
      {
        motor[LBDrive] = fullPower;
        motor[LFDrive] = fullPower;
        motor[RBDrive] = fullNegPower;
        motor[RFDrive] = fullNegPower;
      }
    }
  }
  else
  {
    if(halfPower)
    {
      while(SensorValue(gyro) < 2700)
      {
        motor[RBDrive] = halfPow;
        motor[RFDrive] = halfPow;
        motor[LBDrive] = negHalfPow;
        motor[LFDrive] = negHalfPow;
      }
    }
    else if(!halfPower)
    {
      while(SensorValue(gyro) < 2700)
      {
        motor[RBDrive] = fullPower;
        motor[RFDrive] = fullPower;
        motor[LBDrive] = fullNegPower;
        motor[LFDrive] = fullNegPower;
      }
    }
  }
}

task displayBatteryLevel()
{
  clearLCDLine(0);
  clearLCDLine(1);
  displayNextLCDNumber(nImmediateBatteryLevel, 4);
}


task autonomousHelper()
{
  if(time1(T4) % 100 == 0)
  {
    writeDebugStream("Time: %d", nPgmTime);
    writeDebugStream("Encoder Count: %d", SensorValue(leftDrive));
    writeDebugStream("LBDrive: %d", motor[LBDrive]);
    writeDebugStream("LFDrive %d", motor[LFDrive]);
    writeDebugStream("RFDrive %d", motor[RFDrive]);
    writeDebugStream("RBDrive %d", motor[RBDrive]);
    writeDebugStream("Gyro Value %d", SensorValue(gyro));
    writeDebugStream("Arm Potent %d", SensorValue(pot));
    writeDebugStream("Intake Potent %d", SensorValue(intakePot));
  }
}

void printToDebugStream()
{
  writeDebugStream("ArcadeControl")
}
/*
* 675Delta's Sack Attack Code
* Main Programmer: Jacob Bradberry
* Assistant Programmers: Karima Ah, Jeet Patel
*/

/*
WHAT THIS CODE STILL NEEDS
- Arm Control(Probably going to be a 4 bar powered by either 2 or 4 high torque motors
- Intake Control(If we go with the design where you use linear sliders to rotate the "forklift metal")
- Autonomous functions and incorporation with the autonomousTestingTask
- Possibly attempt to move all the variables and voids to a seperate file(will take a lot of work)
*/
